"""
FastAPI backend service for RAG agent integration.

This module provides a FastAPI application that exposes endpoints to interact
with the RAG agent for querying book content.
"""
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
import logging
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Initialize logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Create FastAPI app instance
app = FastAPI(
    title="Book RAG API",
    description="API for querying book content using RAG agent",
    version="1.0.0"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, replace with specific origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Import the RAG agent after app initialization to avoid circular imports
try:
    from .agent import RAGAgent
except ImportError:
    # Handle relative import when running as module
    import sys
    from pathlib import Path
    # Add the parent directory to the path to import agent
    sys.path.append(str(Path(__file__).parent))
    from agent import RAGAgent

class QueryRequest(BaseModel):
    """Request model for query endpoint."""
    query: str = Field(..., min_length=1, max_length=1000, description="The user's question about the book content")
    context: Optional[str] = Field(None, description="Additional context for the query")
    user_id: Optional[str] = Field(None, description="Identifier for the user making the request")


class SourceInfo(BaseModel):
    """Model for source information."""
    content: str = Field(..., description="The text content of the source")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata about the source")
    score: Optional[float] = Field(None, ge=0, le=1, description="Relevance score for this source")


class QueryResponse(BaseModel):
    """Response model for query endpoint."""
    answer: str = Field(..., description="The answer generated by the system")
    confidence: Optional[float] = Field(None, ge=0, le=1, description="Confidence score between 0 and 1")
    sources: List[SourceInfo] = Field(..., description="List of source references used to generate the answer")
    query_id: Optional[str] = Field(None, description="Unique identifier for the query")
    timestamp: Optional[str] = Field(None, description="ISO 8601 timestamp of the response")


class ErrorResponse(BaseModel):
    """Model for error responses."""
    error: str = Field(..., description="Error type")
    message: str = Field(..., description="Description of the error")
    status_code: int = Field(..., description="HTTP status code")


# Initialize RAG agent
rag_agent = RAGAgent()

@app.get("/")
async def root():
    """Health check endpoint."""
    return {"message": "Book RAG API is running"}


@app.post("/query", response_model=QueryResponse)
async def query_endpoint(request: QueryRequest):
    """
    Process a user query against the book content and return a structured response
    with answer, confidence score, and source references.
    """
    try:
        # Validate query length (this is also handled by Pydantic, but adding explicit check)
        query_text = request.query.strip()
        if len(query_text) == 0:
            raise HTTPException(status_code=400, detail="Query cannot be empty")

        if len(query_text) > 1000:
            raise HTTPException(status_code=400, detail="Query too long, must be less than 1000 characters")

        # Process query with RAG agent
        try:
            result = rag_agent.process_query_sync(query_text)
        except Exception as agent_error:
            logger.error(f"Error processing query with RAG agent: {str(agent_error)}")
            # Handle specific agent errors more gracefully
            error_msg = str(agent_error).lower()

            if "api" in error_msg or "key" in error_msg or "authentication" in error_msg:
                # Handle API key or authentication issues
                logger.error("API authentication error - check your API keys")
                answer = "Service temporarily unavailable due to authentication issues. Please check API configuration."
            elif "connection" in error_msg or "timeout" in error_msg:
                # Handle connection issues
                logger.error("Connection error to external service")
                answer = "Service temporarily unavailable due to connection issues."
            elif "not found" in error_msg or "no answer" in error_msg:
                # Handle cases where no answer was found in the book content
                logger.info("No answer found in book content")
                answer = "I couldn't find an answer to your question in the book content."
            else:
                # Handle other agent errors
                logger.error(f"Unexpected agent error: {agent_error}")
                answer = "I encountered an issue processing your query. Please try again later."

            # Return a response even when agent fails
            response = QueryResponse(
                answer=answer,
                confidence=0.0,
                sources=[],
            )
            return response

        # Extract answer from result
        answer = result.get("response", "No answer found in the book content.")

        # For now, using a placeholder confidence score
        # The RAG agent doesn't directly expose the source chunks in its result
        # In a more complete implementation, we would need to modify the agent to return source info
        sources = []
        confidence = 0.8  # Placeholder confidence score

        response = QueryResponse(
            answer=answer,
            confidence=confidence,
            sources=sources,
        )

        return response
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Unexpected error processing query: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error processing query")


@app.exception_handler(500)
async def internal_exception_handler(request, exc):
    """Global exception handler for internal server errors."""
    logger.error(f"Internal server error: {str(exc)}")
    return JSONResponse(
        status_code=500,
        content={
            "error": "Internal Server Error",
            "message": "An unexpected error occurred",
            "status_code": 500
        }
    )


@app.exception_handler(400)
async def bad_request_handler(request, exc):
    """Global exception handler for bad requests."""
    logger.warning(f"Bad request: {str(exc)}")
    return JSONResponse(
        status_code=400,
        content={
            "error": "Bad Request",
            "message": str(exc) if str(exc) else "Invalid request",
            "status_code": 400
        }
    )


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

